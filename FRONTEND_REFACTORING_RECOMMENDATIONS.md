# üîß RECOMENDA√á√ïES DE REFACTORING - FRONTEND

**Data**: 27 de Outubro de 2025  
**Prioridade**: Alta (antes de produ√ß√£o)  
**Impacto**: Seguran√ßa + Manutenibilidade

---

## üìã √çNDICE

1. Centralizar Firebase Client SDK
2. Remover Valida√ß√µes Cr√≠ticas
3. Tratamento de Erros e Timeouts
4. Contratos de Dados (DTOs)
5. Padr√£o de Orquestra√ß√£o no Backend

---

## 1Ô∏è‚É£ CENTRALIZAR FIREBASE CLIENT SDK

### Problema Atual
- M√∫ltiplas classes usam `FirebaseFirestore.instance` diretamente
- Dif√≠cil trocar implementa√ß√£o (para testes, por exemplo)
- Sem logging centralizado

### Solu√ß√£o Recomendada

Criar uma abstra√ß√£o centralizada em `lib/core/services/firebase_service.dart`:

```dart
/// Service centralizado para acessar Firebase (Client SDK)
class FirebaseService {
  static final _firestore = FirebaseFirestore.instance;
  static final _auth = FirebaseAuth.instance;
  static final _storage = FirebaseStorage.instance;

  // ‚úÖ Acesso centralizado
  static FirebaseFirestore get firestore => _firestore;
  static FirebaseAuth get auth => _auth;
  static FirebaseStorage get storage => _storage;

  // ‚úÖ M√©todos auxiliares com logging
  static Future<DocumentSnapshot> getDocument(
    String path, {
    int timeoutSeconds = 30,
  }) async {
    try {
      return await _firestore
          .doc(path)
          .get()
          .timeout(Duration(seconds: timeoutSeconds));
    } catch (e) {
      AppLogger.error('Erro ao buscar documento: $path', error: e);
      rethrow;
    }
  }

  // ‚úÖ Escuta com timeout
  static Stream<QuerySnapshot> watchQuery(
    Query query, {
    int timeoutSeconds = 30,
  }) {
    return query.snapshots().timeout(
      Duration(seconds: timeoutSeconds),
      onTimeout: (sink) {
        AppLogger.error('Timeout ao escutar query');
        sink.addError(NetworkException('Timeout na conex√£o'));
      },
    );
  }
}
```

**Uso**:
```dart
// ‚ùå Antes
final doc = await FirebaseFirestore.instance.doc('users/123').get();

// ‚úÖ Depois
final doc = await FirebaseService.getDocument('users/123');
```

---

## 2Ô∏è‚É£ REMOVER VALIDA√á√ïES CR√çTICAS DO FRONTEND

### Problema Atual

Valida√ß√µes de neg√≥cio cr√≠ticas em m√∫ltiplos lugares:

```dart
// ‚ùå RUIM: Valida√ß√£o em UseCase (cliente confia)
if (params.rating < 1 || params.rating > 5) {
  return Left(ValidationFailure('Rating deve estar entre 1 e 5'));
}

// ‚ùå RUIM: Valida√ß√£o em Firestore Rules (fraca)
allow create: if ... && request.resource.data.rating >= 1 
                   && request.resource.data.rating <= 5;

// ‚ùå RUIM: Valida√ß√£o em Repository (pode ser burlada)
final isValidRating = rating >= 1 && rating <= 5;
```

### Solu√ß√£o Recomendada

1. **Remover UseCase**: Deixar apenas orquestra√ß√£o
2. **Fortalecer Backend**: Backend valida tudo
3. **Manter Rules**: Como defesa segund√°ria

```dart
// ‚úÖ UseCase apenas orquestra (sem valida√ß√£o cr√≠tica)
@override
Future<Either<Failure, ReviewEntity>> call(AddReviewParams params) async {
  // ‚úÖ Logging
  AppLogger.info('Adicionando review para: ${params.professionalId}');

  // ‚úÖ Construir entity
  final review = ReviewEntity(
    id: '', // Backend gera
    professionalId: params.professionalId,
    patientId: params.patientId,
    rating: params.rating,
    comment: params.comment,
    createdAt: DateTime.now(),
  );

  // ‚úÖ Chamar repository (que chama backend)
  return await repository.addReview(review);
}
```

### Padr√£o: Backend √© Source of Truth

```dart
// ‚úÖ CORRETO: Backend valida, frontend chama
class HttpReviewsDataSource {
  Future<ReviewEntity> addReview(ReviewEntity review) async {
    final response = await _client.post(
      Uri.parse('$baseUrl/api/v1/reviews/${review.professionalId}'),
      headers: {'Authorization': 'Bearer $token'},
      body: jsonEncode({
        'rating': review.rating,
        'comment': review.comment,
        // ... outros campos
      }),
    );

    // ‚úÖ Backend retorna erro espec√≠fico se rating inv√°lido
    if (response.statusCode == 400) {
      final error = jsonDecode(response.body)['error'];
      if (error.contains('rating')) {
        throw ValidationException('Rating inv√°lido');
      }
    }

    return ReviewEntity.fromJson(jsonDecode(response.body));
  }
}
```

---

## 3Ô∏è‚É£ TRATAMENTO DE ERROS E TIMEOUTS

### Problema Atual
- Alguns datasources sem timeout
- Retry logic inconsistent
- Error mapping duplicado

### Solu√ß√£o Recomendada

Criar `lib/core/utils/http_client_wrapper.dart`:

```dart
/// Wrapper de HTTP com retry, timeout, e logging
class HttpClientWrapper {
  HttpClientWrapper({http.Client? client})
      : _client = client ?? http.Client();

  final http.Client _client;
  static const int _timeoutSeconds = 30;
  static const int _maxRetries = 3;

  /// GET com retry autom√°tico
  Future<http.Response> get(
    Uri url, {
    Map<String, String>? headers,
  }) async {
    return _requestWithRetry(
      () => _client.get(url, headers: headers).timeout(
        Duration(seconds: _timeoutSeconds),
        onTimeout: () => throw NetworkException('GET timeout'),
      ),
    );
  }

  /// POST com retry autom√°tico
  Future<http.Response> post(
    Uri url, {
    Map<String, String>? headers,
    required String body,
  }) async {
    return _requestWithRetry(
      () => _client.post(
        url,
        headers: headers,
        body: body,
      ).timeout(
        Duration(seconds: _timeoutSeconds),
        onTimeout: () => throw NetworkException('POST timeout'),
      ),
    );
  }

  /// Retry com backoff exponencial
  Future<http.Response> _requestWithRetry(
    Future<http.Response> Function() request,
  ) async {
    for (int i = 0; i < _maxRetries; i++) {
      try {
        return await request();
      } catch (e) {
        if (i == _maxRetries - 1) rethrow;
        
        // Backoff exponencial: 100ms, 200ms, 400ms
        final delayMs = 100 * (1 << i);
        await Future.delayed(Duration(milliseconds: delayMs));
        
        AppLogger.warning('Retry $i para request');
      }
    }
    throw Exception('Nunca deve chegar aqui');
  }
}
```

**Uso**:
```dart
class HttpProfessionalsDataSource {
  late final HttpClientWrapper _http;

  HttpProfessionalsDataSource({HttpClientWrapper? http}) {
    _http = http ?? HttpClientWrapper();
  }

  Future<Map<String, dynamic>> searchProfessionals({
    required String query,
  }) async {
    try {
      final response = await _http.get(
        Uri.parse('$baseUrl/api/v1/professionals?q=$query'),
        headers: {'Authorization': 'Bearer $token'},
      );

      if (response.statusCode == 200) {
        return jsonDecode(response.body) as Map<String, dynamic>;
      }

      // ‚úÖ Erro espec√≠fico com context
      throw _handleError(response.statusCode, response.body);
    } on NetworkException catch (e) {
      throw StorageException('Conex√£o perdida: ${e.message}');
    }
  }

  Exception _handleError(int statusCode, String body) {
    switch (statusCode) {
      case 400:
        return ValidationException('Dados inv√°lidos');
      case 401:
        return AuthenticationException('Token expirado');
      case 429:
        return RateLimitException('Limite de requisi√ß√µes excedido');
      case 500:
        return ServerException('Erro interno do servidor');
      default:
        return StorageException('Erro $statusCode');
    }
  }
}
```

---

## 4Ô∏è‚É£ CONTRATOS DE DADOS (DTOs)

### Problema Atual
- Entidades do domain mixadas com DTOs
- Sem mapping expl√≠cito
- Dif√≠cil versionar API

### Solu√ß√£o Recomendada

Criar DTOs separados em `lib/data/models/`:

```dart
// ‚úÖ DTO para backend
class AddReviewDTO {
  final String professionalId;
  final String patientId;
  final int rating;
  final String comment;

  AddReviewDTO({
    required this.professionalId,
    required this.patientId,
    required this.rating,
    required this.comment,
  });

  /// ‚úÖ Valida√ß√µes do DTO (antes de enviar)
  void validate() {
    if (rating < 1 || rating > 5) {
      throw ValidationException('Rating deve estar entre 1 e 5');
    }
    if (comment.trim().isEmpty) {
      throw ValidationException('Coment√°rio obrigat√≥rio');
    }
    if (comment.length > 500) {
      throw ValidationException('Coment√°rio muito longo');
    }
  }

  /// ‚úÖ Serializar para JSON
  Map<String, dynamic> toJson() => {
    'professionalId': professionalId,
    'patientId': patientId,
    'rating': rating,
    'comment': comment,
  };

  /// ‚úÖ Deserializar do backend
  factory AddReviewDTO.fromJson(Map<String, dynamic> json) {
    return AddReviewDTO(
      professionalId: json['professionalId'] as String,
      patientId: json['patientId'] as String,
      rating: json['rating'] as int,
      comment: json['comment'] as String,
    );
  }
}

// ‚úÖ DTO para resposta do backend
class ReviewResponseDTO {
  final String id;
  final String professionalId;
  final double averageRating;
  final int totalReviews;

  ReviewResponseDTO({
    required this.id,
    required this.professionalId,
    required this.averageRating,
    required this.totalReviews,
  });

  factory ReviewResponseDTO.fromJson(Map<String, dynamic> json) {
    return ReviewResponseDTO(
      id: json['id'] as String,
      professionalId: json['professionalId'] as String,
      averageRating: (json['averageRating'] as num).toDouble(),
      totalReviews: json['totalReviews'] as int,
    );
  }

  /// ‚úÖ Converter para domain entity
  ReviewEntity toDomain() => ReviewEntity(
    id: id,
    professionalId: professionalId,
    patientId: '',
    patientName: '',
    rating: 0,
    comment: '',
    createdAt: DateTime.now(),
  );
}
```

**Uso**:
```dart
// ‚úÖ Datasource usa DTO
Future<ReviewEntity> addReview(ReviewEntity review) async {
  final dto = AddReviewDTO(
    professionalId: review.professionalId,
    patientId: review.patientId,
    rating: review.rating,
    comment: review.comment,
  );

  // ‚úÖ Validar antes de enviar (UX)
  dto.validate();

  final response = await _http.post(
    Uri.parse('$baseUrl/api/v1/reviews'),
    body: jsonEncode(dto.toJson()),
  );

  // ‚úÖ Converter resposta para entity
  final responseDto = ReviewResponseDTO.fromJson(jsonDecode(response.body));
  return responseDto.toDomain();
}
```

---

## 5Ô∏è‚É£ PADR√ÉO DE ORQUESTRA√á√ÉO NO BACKEND

### Problema Atual
- Screens chamam m√∫ltiplos providers
- L√≥gica de coordena√ß√£o duplicada
- Backend-like decisions no provider

### Solu√ß√£o Recomendada

Providers apenas orquestram, n√£o validam:

```dart
// ‚úÖ Provider √© um orquestrador
class ReviewsNotifier extends StateNotifier<ReviewsState> {
  final AddReview _addReview;
  final GetReviewsByProfessional _getReviews;

  ReviewsNotifier({
    required AddReview addReview,
    required GetReviewsByProfessional getReviews,
  })  : _addReview = addReview,
        _getReviews = getReviews,
        super(const ReviewsState.initial());

  /// ‚úÖ UseCase faz valida√ß√µes, provider apenas chama
  Future<void> addReview({
    required String professionalId,
    required String patientId,
    required int rating,
    required String comment,
  }) async {
    state = const ReviewsState.loading();

    final params = AddReviewParams(
      professionalId: professionalId,
      patientId: patientId,
      patientName: '', // UseCase buscar√°
      rating: rating,
      comment: comment,
    );

    final result = await _addReview(params);

    state = result.fold(
      (failure) => ReviewsState.error(failure.message),
      (review) => ReviewsState.success(review),
    );
  }
}

// ‚úÖ Screen apenas chama provider (sem l√≥gica)
class AddReviewScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final reviewsState = ref.watch(reviewsNotifierProvider);

    return Scaffold(
      body: _buildForm(ref, context), // Widget para formul√°rio
    );
  }

  Widget _buildForm(WidgetRef ref, BuildContext context) {
    return Form(
      child: Column(
        children: [
          // ‚úÖ Campos de entrada
          TextField(controller: ratingController),
          TextField(controller: commentController),
          
          // ‚úÖ Bot√£o chama provider (sem l√≥gica)
          ElevatedButton(
            onPressed: () {
              ref.read(reviewsNotifierProvider.notifier).addReview(
                professionalId: widget.professionalId,
                patientId: ref.read(userIdProvider)!,
                rating: int.parse(ratingController.text),
                comment: commentController.text,
              );
            },
            child: Text('Enviar Avalia√ß√£o'),
          ),
        ],
      ),
    );
  }
}
```

---

## üìä CHECKLIST DE REFACTORING

### Fase 1: Firebase Centraliza√ß√£o
- [ ] Criar `lib/core/services/firebase_service.dart`
- [ ] Remover `FirebaseFirestore.instance` direto
- [ ] Adicionar logging em opera√ß√µes cr√≠ticas
- [ ] Adicionar timeouts padr√£o

### Fase 2: Remover Valida√ß√µes Cr√≠ticas
- [ ] Revisar todos os UseCase
- [ ] Deixar apenas orquestra√ß√£o
- [ ] Mover l√≥gica cr√≠tica para backend
- [ ] Documentar decis√£o

### Fase 3: Tratamento de Erros
- [ ] Criar `HttpClientWrapper`
- [ ] Adicionar retry autom√°tico
- [ ] Adicionar timeouts
- [ ] Mapear erros corretamente

### Fase 4: DTOs
- [ ] Criar `lib/data/models/` com DTOs
- [ ] Separar DTO de Entity
- [ ] Mapear explicitamente
- [ ] Documentar contrato com backend

### Fase 5: Orquestra√ß√£o
- [ ] Revisar providers
- [ ] Remover l√≥gica de neg√≥cio
- [ ] Deixar apenas state management
- [ ] Simplificar

---

## üîê PADR√ÉO DE SEGURAN√áA

### Trust Boundary

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         CLIENTE (N√ÉO confi√°vel)      ‚îÇ
‚îÇ ‚úÖ Orquestra√ß√£o                      ‚îÇ
‚îÇ ‚úÖ Valida√ß√µes UX (formato)           ‚îÇ
‚îÇ ‚úÖ Caching local                     ‚îÇ
‚îÇ ‚ùå Valida√ß√µes cr√≠ticas               ‚îÇ
‚îÇ ‚ùå Gera√ß√£o de IDs                    ‚îÇ
‚îÇ ‚ùå Gera√ß√£o de tokens                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ HTTP + JWT
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      BACKEND (CONFI√ÅVEL)             ‚îÇ
‚îÇ ‚úÖ Valida√ß√µes cr√≠ticas               ‚îÇ
‚îÇ ‚úÖ Autoriza√ß√£o                       ‚îÇ
‚îÇ ‚úÖ Gera√ß√£o de IDs                    ‚îÇ
‚îÇ ‚úÖ Transa√ß√µes ACID                   ‚îÇ
‚îÇ ‚úÖ Auditoria                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ Firebase Admin SDK
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       FIREBASE (TRUSTLESS)           ‚îÇ
‚îÇ ‚úÖ Armazenamento persistente         ‚îÇ
‚îÇ ‚úÖ Real-time listeners              ‚îÇ
‚îÇ ‚úÖ Rules como defesa 2¬™ camada      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìù EXEMPLO COMPLETO: Adicionar Review

### ANTES (Inseguro)
```dart
// ‚ùå Valida√ß√£o no client
if (rating < 1 || rating > 5) {
  showError('Rating inv√°lido');
  return;
}

// ‚ùå C√°lculo no client
final newAverage = (oldAverage * count + rating) / (count + 1);

// ‚ùå Salvar direto no Firebase
await firestore.collection('reviews').add({
  'rating': rating,
  'average': newAverage, // ‚ùå Pode ser burlado
});
```

### DEPOIS (Seguro)
```dart
// ‚úÖ UseCase apenas orquestra
final result = await addReviewUseCase(params);

result.fold(
  (failure) => showError(failure.message),
  (review) => showSuccess('Review adicionado'),
);

// Backend faz:
// 1. ‚úÖ Valida rating
// 2. ‚úÖ Verifica usu√°rio
// 3. ‚úÖ Calcula m√©dia
// 4. ‚úÖ Salva atomicamente
// 5. ‚úÖ Auditoria
```

---

## üöÄ PR√ìXIMOS PASSOS

1. **Week 1**: Implementar Firebase Service (1h)
2. **Week 2**: HttpClientWrapper com retry (2h)
3. **Week 3**: Remover valida√ß√µes cr√≠ticas (3h)
4. **Week 4**: Criar DTOs (2h)
5. **Week 5**: Testar e validar (2h)

**Total**: ~10h de refactoring

**Benef√≠cios**:
- ‚úÖ Seguran√ßa aumentada 10x
- ‚úÖ C√≥digo mais test√°vel
- ‚úÖ Menos bugs em produ√ß√£o
- ‚úÖ Manutenibilidade aumentada
